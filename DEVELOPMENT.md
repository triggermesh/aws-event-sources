# Development

## Contents

1. [Running the controller](#running-the-controller)
   * [Locally](#locally)
   * [Inside a cluster](#inside-a-cluster)
1. [Adding event sources](#adding-event-sources)
   * [Type definition](#type-definition)
   * [Custom resource definition](#custom-resource-definition)
   * [Reconciler](#reconciler)
   * [Adapter](#adapter)

## Running the controller

### Locally

Providing that the local environment is configured with a valid kubeconfig (either in `~/.kube/config` or set via the
`KUBECONFIG` environment variable), running the controller locally from the current development branch is as simple as
executing

```
$ go run ./cmd/aws-event-sources-controller
```

> :information_source: The source controller requires a few environment variables to be exported in order to start.
>
> `SYSTEM_NAMESPACE`
>
> The namespace in which the controller sources its configuration from (logging, observability). This can potentially be
> set to any namespace, including `default`, since the controller falls back to a default configuration if the
> aforementioned ConfigMaps are missing.
>
> `METRICS_DOMAIN`
>
> The domain to use for surfacing metrics.
>
> **Optional**. Only required when a ConfigMap for observability (`config-observability` by default) actually exists in
> the namespace defined by `SYSTEM_NAMESPACE`.

### Inside a cluster

One can build/push container images and deploy all relevant Kubernetes objects to a running cluster in a single command
using [ko](https://github.com/google/ko).

```
$ ko apply --local -f config/
...
2020/04/07 13:44:00 Using base gcr.io/distroless/static:latest for github.com/triggermesh/aws-event-sources/cmd/aws-event-sources-controller
2020/04/07 13:44:01 Building github.com/triggermesh/aws-event-sources/cmd/aws-event-sources-controller
2020/04/07 13:44:05 Loading ko.local/aws-event-sources-controller-0d0554a556
2020/04/07 13:44:06 Loaded ko.local/aws-event-sources-controller-0d0554a556
2020/04/07 13:44:06 Adding tag latest
2020/04/07 13:44:06 Added tag latest
deployment.apps/aws-event-sources-controller created
```

The controller will be deployed to the `triggermesh` namespace.

```console
$ kubectl -n triggermesh get deployment/aws-event-sources-controller
NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
aws-event-sources-controller   1/1     1            1           1m
```

> :information_source: Although `ko` does not make use of the `docker` client, the `--local` flag assumes the
> development environment is properly configured to import images in a Docker daemon. On `minikube`, for example, it is
> assumed that the environment variables defined by `minikube docker-env` are exported.
>
> Please refer to the `ko` documentation for further usage instructions.

## Adding event sources

Follow these steps to add a new source to this repository.

### Type definition

Inside the `pkg/apis/sources/v1alpha1/` directory:

1. Add the Go structs for your type to a new file following the naming convention `<RESOURCE>_types.go`.

1. Add the defaulting methods for your type to a new file following the naming convention `<RESOURCE>_defaults.go`.

1. Add the validation methods for your type to a new file following the naming convention `<RESOURCE>_validation.go`.

1. Add the methods relevant to the lifecycle management of your type (status updates, etc.) to a new file following the
   naming convention `<RESOURCE>_lifecycle.go`.

Finally, generate the client, lister, informer and injection code using `make codegen`.

| :warning: The Kubernetes code generators write their output to a directory named `github.com/triggermesh/aws-event-sources` relatively to`$GOPATH/src/`. Therefore, you must ensure your repository is cloned to this exact location prior to running any code generator. |
| :--- |

### Custom resource definition

A `CustomResourceDefinition` object is required to register the new type into Kubernetes. A manifest for that object
should be created inside the `config/` directory following the naming convention `300-<RESOURCE>.yaml`.

### Reconciler

Each source type is managed by its own _reconciler_. A reconciler is responsible for deploying an event source and
synchronizing it with its corresponding API object (the custom type created above). In the Knative terminology, the
application that implements the logic of the event source is called an _adapter_ (sometimes _receive-adapter_).

To create a new reconciler, start by creating a new directory under `pkg/reconciler/` with the name of your resource,
then:

1. Copy the generated code from `pkg/client/generated/injection/reconciler/sources/v1alpha1/<RESOURCE>/stub/` to that
   directory.

1. Remove the `// Code generated by injection-gen. DO NOT EDIT.` comment from both `controller.go` and `reconciler.go`
   files.

1. Implement the `TODO`s in those same files. See existing reconcilers for best practices.

1. Add the reconciler's `NewController` method to the shared `main` inside `cmd/controller/main.go`.

### Adapter

The adapter implements the business logic of the event source. It is decoupled from the reconciler, the contract between
the two is usually based on environment variables that can be used to inject parameters to the adapter.

1. Create a `main` package for the source's adapter in `cmd/<RESOURCE>`.

1. If specific libraries are needed for that adapter, write them under `pkg/adapter/<RESOURCE>`.
